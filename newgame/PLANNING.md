# 项目计划：细菌式 Roguelite (PLANNING.md)

本文档基于 `CLAUDE.md` 的“细菌代码原则”和 `INITIAL.md` 的功能规格，为游戏的开发制定一份高度模块化、低耦合的项目计划。

## 核心原则：解耦与独立

每个“操纵子”（Operon）都是一个独立的基因单元，必须能够**独立开发、独立测试、独立运行**。它们之间通过标准化的数据接口（如字典）进行通信，而不是直接调用。

---

## 第一阶段：核心生存能力的实现 (Milestone 1: Core Viability)

目标：构建一个最基础的可玩循环，验证核心机制。

| 任务 (Task) | 操纵子 (Operon) | 产出 (Output) | 依赖 (Dependencies) | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| [x] **1. 游戏主循环** | `main.py` | 一个可以运行的空白窗口 | `pygame` | 建立游戏的基本框架，处理窗口和事件。 |
| [x] **2. 资源加载** | `resource_operon.py` | 加载图片和地图路径的函数 | 无 | 一个独立的资源管理器，根据路径配置加载资源。 |
| [x] **3. 输入处理** | `input_operon.py` | 返回包含玩家动作的字典 | 无 | 纯函数式模块，将硬件输入转换为游戏内动作（如`{'move_x': 1, 'jump': True}`）。 |
| [x] **4. 玩家物理** | `movement_operon.py` | 管理玩家对象的位置和状态 | 输入字典 | 接收输入字典，更新玩家的物理状态（位置、速度）。**不处理渲染**。 |

**里程碑验证**：
- [x] 运行 `main.py`，一个代表玩家的方块可以根据 A/D 键移动，根据空格键跳跃。
- [x] 所有模块代码行数严格遵守 `CLAUDE.md` 的限制。

---

## 第二阶段：战斗系统的建立 (Milestone 2: Combat System)

目标：实现完整的攻击、受击、伤害计算流程。

| 任务 (Task) | 操纵子 (Operon) | 产出 (Output) | 依赖 (Dependencies) | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| [ ] **1. 武器管理** | `weapon_operon.py` | 管理4个武器槽位和当前武器 | 输入字典 | 根据输入字典（`'attack'`），返回当前武器的攻击数据（如`{'type': 'melee', 'damage': 10}`）。 |
| [ ] **2. 敌人AI** | `enemy_operon.py` | 管理所有敌人对象 | 玩家位置 | 接收玩家位置，更新所有敌人的状态。**不处理伤害**。 |
| [ ] **3. 战斗计算** | `combat_operon.py` | 处理所有伤害和效果 | 攻击数据, 实体列表 | 接收攻击数据和所有实体（玩家、敌人），计算伤害并更新实体的生命值。 |

**里程碑验证**：
- [ ] 玩家按下攻击键时，`combat_operon` 能接收到攻击事件。
- [ ] 当玩家和敌人重叠时，`combat_operon`能正确计算伤害并更新生命值。
- [ ] 每个模块都可以独立测试（例如，`test_combat.py` 可以不依赖 `pygame`）。

---

## 第三阶段：游戏世界的构建 (Milestone 3: World Building)

目标：程序化生成关卡，并加入互动元素。

| 任务 (Task) | 操纵子 (Operon) | 产出 (Output) | 依赖 (Dependencies) | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| [ ] **1. 关卡生成** | `generation_operon.py` | 返回一个包含实体位置的列表 | 无 | 独立模块，根据算法或地图文件（`.tmx`）生成敌人和道具的初始位置列表。 |
| [ ] **2. NPC系统** | `npc_operon.py` | 管理所有NPC对象 | 输入字典, 玩家位置 | 根据交互输入和玩家位置，返回对话或商店UI的请求。 |
| [ ] **3. 平台与环境** | `platform_operon.py` | 管理所有平台和环境对象 | 无 | 存储所有静态碰撞体（地面、墙壁）的数据。 |

**里程碑验证**：
- [ ] 启动游戏时，`generation_operon` 会创建一组敌人。
- [ ] 玩家靠近NPC并按E键时，会触发交互事件。
- [ ] `movement_operon` 从 `platform_operon` 获取碰撞信息。

---

## 第四阶段：成长与循环 (Milestone 4: Progression & Loop)

目标：实现Roguelite的核心循环和玩家成长系统。

| 任务 (Task) | 操纵子 (Operon) | 产出 (Output) | 依赖 (Dependencies) | 描述 |
| :--- | :--- | :--- | :--- | :--- |
| [ ] **1. 成长系统** | `progression_operon.py` | 管理玩家的经验、等级和技能 | 事件（如`enemy_defeated`） | 接收游戏事件，更新玩家的属性和技能树。 |
| [ ] **2. Roguelite循环** | `roguelite_operon.py` | 管理游戏状态（开始、结束、死亡） | 玩家生命值 | 监控玩家状态，处理死亡、重生和永久性升级。 |
| [ ] **3. UI系统** | `ui_operon.py` | 显示所有UI元素 | 各系统状态 | 接收来自其他系统的数据（如生命值、武器），并将其渲染到屏幕上。 |

**里程碑验证**：
- [ ] 击败敌人后，`progression_operon` 会增加经验值。
- [ ] 玩家死亡后，`roguelite_operon` 会重置关卡但保留部分进度。
- [ ] `ui_operon` 能正确显示血条和武器图标。

---

## 耦合控制策略 (Decoupling Strategy)

- **无直接调用**：操纵子之间**绝不**直接相互 `import` 或调用对方的函数/方法。
- **数据驱动**：所有通信通过 `main.py` 中的主循环进行协调，传递标准化的Python字典。
- **职责单一**：每个操纵子只做一件事。例如，`movement_operon` 只管移动，不管攻击；`combat_operon` 只管伤害，不管移动。
- **独立测试**：为每个操纵子创建独立的测试文件（如 `tests/test_combat_operon.py`），确保其逻辑不依赖于游戏主循环或 `pygame`。

这个计划确保了每个部分都可以像细菌一样独立生存和进化，最大程度地降低了开发的复杂性。
